<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Graphs: Graph::Algorithms Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">Graphs<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">Simple House of Graphs compliant graph software</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('dd/d33/class_graph_1_1_algorithms.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="../../d9/d02/class_graph_1_1_algorithms-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph::Algorithms Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Virtual class providing the algorithmic interface.  
 <a href="../../dd/d33/class_graph_1_1_algorithms.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d8/d84/_algorithms_8h_source.html">Algorithms.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4249ea9cfd206236a072256be620bfb9"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d33/class_graph_1_1_algorithms.html#a4249ea9cfd206236a072256be620bfb9">greedy_coloring</a> (bool permutate=false, std::ostream *log_stream=nullptr)=0</td></tr>
<tr class="memdesc:a4249ea9cfd206236a072256be620bfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common definition of the function providing ordering and permutation sequence according to the greedy algorithm rules.  <a href="../../dd/d33/class_graph_1_1_algorithms.html#a4249ea9cfd206236a072256be620bfb9">More...</a><br /></td></tr>
<tr class="separator:a4249ea9cfd206236a072256be620bfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4d052c3c1823d7547e105dc415c1c2"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d33/class_graph_1_1_algorithms.html#aaf4d052c3c1823d7547e105dc415c1c2">lf_coloring</a> (bool permutate=false, std::ostream *log_stream=nullptr)=0</td></tr>
<tr class="memdesc:aaf4d052c3c1823d7547e105dc415c1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common definition of the function providing ordering and permutation sequence according to the LF algorithm rules.  <a href="../../dd/d33/class_graph_1_1_algorithms.html#aaf4d052c3c1823d7547e105dc415c1c2">More...</a><br /></td></tr>
<tr class="separator:aaf4d052c3c1823d7547e105dc415c1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8491653a336a3a547504cad5b0079c"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d33/class_graph_1_1_algorithms.html#adf8491653a336a3a547504cad5b0079c">sl_coloring</a> (bool permutate=false, std::ostream *log_stream=nullptr)=0</td></tr>
<tr class="memdesc:adf8491653a336a3a547504cad5b0079c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common definition of the function providing ordering and permutation sequence according to the SL algorithm rules.  <a href="../../dd/d33/class_graph_1_1_algorithms.html#adf8491653a336a3a547504cad5b0079c">More...</a><br /></td></tr>
<tr class="separator:adf8491653a336a3a547504cad5b0079c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1060857b3a127f8bb61d5360f332972"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d3/dd6/class_graph_1_1_roadmap.html">Roadmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d33/class_graph_1_1_algorithms.html#af1060857b3a127f8bb61d5360f332972">belman_ford_point_to_all</a> (std::size_t start, std::ostream *log_stream=nullptr)=0</td></tr>
<tr class="memdesc:af1060857b3a127f8bb61d5360f332972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common definition of the function providing the Belman-Ford path-searching algorithm implementation.  <a href="../../dd/d33/class_graph_1_1_algorithms.html#af1060857b3a127f8bb61d5360f332972">More...</a><br /></td></tr>
<tr class="separator:af1060857b3a127f8bb61d5360f332972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6248bc3669baacada1e3d80f9fa08c14"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d33/class_graph_1_1_algorithms.html#a6248bc3669baacada1e3d80f9fa08c14">belman_ford_point_to_point</a> (std::size_t start, std::size_t destination, std::ostream *log_stream=nullptr)=0</td></tr>
<tr class="memdesc:a6248bc3669baacada1e3d80f9fa08c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common definition of the function providing the Belman-Ford path-searching algorithm, with extraction of point-to-point path.  <a href="../../dd/d33/class_graph_1_1_algorithms.html#a6248bc3669baacada1e3d80f9fa08c14">More...</a><br /></td></tr>
<tr class="separator:a6248bc3669baacada1e3d80f9fa08c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a36537c13d64528d46f7fe4ac67e6b382"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d33/class_graph_1_1_algorithms.html#a36537c13d64528d46f7fe4ac67e6b382">greedy_coloring_core</a> (std::map&lt; int, int &gt; &amp;m, std::ostream *log_stream=nullptr)=0</td></tr>
<tr class="memdesc:a36537c13d64528d46f7fe4ac67e6b382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common definition of the function providing the core coloring functionality.  <a href="../../dd/d33/class_graph_1_1_algorithms.html#a36537c13d64528d46f7fe4ac67e6b382">More...</a><br /></td></tr>
<tr class="separator:a36537c13d64528d46f7fe4ac67e6b382"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Virtual class providing the algorithmic interface. </p>
<p >The class provides common algorithmic interface for each of its inheriting classes. Its main purpose is to provide the Data::Benchmark class with an ability to use those functions without the knowledge of which graph representation was received as a parameter.</p>
<dl class="section attention"><dt>Attention</dt><dd>Each of the coloring algorithms public function provide permutation functionality for randomized trials of efficiency. This functionality is triggered via a parameter to the chosen coloring function. As such, user might try to get an average result by running the function once, or try to get optimal results for the algorithm by running it multiple times with permutations, as does the Data::Benchmark class. For the latter purpose, the use of Data::Benchmark class is recommended, as it provides API to automate the process. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af1060857b3a127f8bb61d5360f332972" name="af1060857b3a127f8bb61d5360f332972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1060857b3a127f8bb61d5360f332972">&#9670;&nbsp;</a></span>belman_ford_point_to_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d3/dd6/class_graph_1_1_roadmap.html">Roadmap</a> Graph::Algorithms::belman_ford_point_to_all </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>log_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common definition of the function providing the Belman-Ford path-searching algorithm implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>ID of the vertex (starting from 0) from which the search for paths to all other vertices should begin. </td></tr>
    <tr><td class="paramname">permutate</td><td>Flag signifing whether the function is supposed to perform a random permutation of the ordering for the coloring. False by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data::Roadmap structure containing all necessary informations regarding the found paths. </dd></dl>

</div>
</div>
<a id="a6248bc3669baacada1e3d80f9fa08c14" name="a6248bc3669baacada1e3d80f9fa08c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6248bc3669baacada1e3d80f9fa08c14">&#9670;&nbsp;</a></span>belman_ford_point_to_point()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::size_t &gt; Graph::Algorithms::belman_ford_point_to_point </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>log_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common definition of the function providing the Belman-Ford path-searching algorithm, with extraction of point-to-point path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>ID of the vertex (starting from 0) from which to search for path to the destination vertex <br  />
 </td></tr>
    <tr><td class="paramname">destination</td><td>ID of the destination vertex </td></tr>
    <tr><td class="paramname">permutate</td><td>Flag signifing whether the function is supposed to perform a random permutation of the ordering for the coloring. False by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a4249ea9cfd206236a072256be620bfb9" name="a4249ea9cfd206236a072256be620bfb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4249ea9cfd206236a072256be620bfb9">&#9670;&nbsp;</a></span>greedy_coloring()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t Graph::Algorithms::greedy_coloring </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permutate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>log_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common definition of the function providing ordering and permutation sequence according to the greedy algorithm rules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permutate</td><td>Flag signifing whether the function is supposed to perform a random permutation of the ordering for the coloring. False by default. </td></tr>
    <tr><td class="paramname">log_stream</td><td>Pointer to the output stream in which logs should be saved. If passed a nullptr, logs will not be produced. Nullptr by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of colors used in the coloring process. </dd></dl>

</div>
</div>
<a id="a36537c13d64528d46f7fe4ac67e6b382" name="a36537c13d64528d46f7fe4ac67e6b382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36537c13d64528d46f7fe4ac67e6b382">&#9670;&nbsp;</a></span>greedy_coloring_core()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t Graph::Algorithms::greedy_coloring_core </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; int, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>log_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common definition of the function providing the core coloring functionality. </p>
<p >This functionality is designed for the algorithms that base on the greedy coloring sequence (once provided the right order of vertices according to their own rules).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Map containing the created ordering of vertices. </td></tr>
    <tr><td class="paramname">permutate</td><td>Flag signifing whether the function is supposed to perform a random permutation of the ordering for the coloring. False by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of colors used in the coloring process. </dd></dl>

</div>
</div>
<a id="aaf4d052c3c1823d7547e105dc415c1c2" name="aaf4d052c3c1823d7547e105dc415c1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4d052c3c1823d7547e105dc415c1c2">&#9670;&nbsp;</a></span>lf_coloring()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t Graph::Algorithms::lf_coloring </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permutate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>log_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common definition of the function providing ordering and permutation sequence according to the LF algorithm rules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permutate</td><td>Flag signifing whether the function is supposed to perform a random permutation of the ordering for the coloring. False by default. </td></tr>
    <tr><td class="paramname">log_stream</td><td>Pointer to the output stream in which logs should be saved. If passed a nullptr, logs will not be produced. Nullptr by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Numer of colors used in the coloring process. </dd></dl>

</div>
</div>
<a id="adf8491653a336a3a547504cad5b0079c" name="adf8491653a336a3a547504cad5b0079c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8491653a336a3a547504cad5b0079c">&#9670;&nbsp;</a></span>sl_coloring()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t Graph::Algorithms::sl_coloring </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permutate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>log_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common definition of the function providing ordering and permutation sequence according to the SL algorithm rules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permutate</td><td>Flag signifing whether the function is supposed to perform a random permutation of the ordering for the coloring. False by default. </td></tr>
    <tr><td class="paramname">log_stream</td><td>Pointer to the output stream in which logs should be saved. If passed a nullptr, logs will not be produced. Nullptr by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Numer of colors used in the coloring process. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d7/dfb/namespace_graph.html">Graph</a></li><li class="navelem"><a class="el" href="../../dd/d33/class_graph_1_1_algorithms.html">Algorithms</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
